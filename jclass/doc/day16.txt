#16

인터페이스(Interface)
=> 클래스의 한 종류이긴 하지만 약간 그 형태나 그의미가 지금까지 배웠던 클래스하고는
다른 특수한 클래스의 일종이다.

특징 
1. 최상위 클래스가 Object가 아니다.
 =>즉 인터페이스는 다른 클래스를 상속받아서 만들어진 클래스가 아니다.
2. 인터페이스 내부에는 100% 추상적인 함수가 존재해야 한다. 
=> 절대로 일반 함수는 존재하지 않는다.
	기능을 가진 함수는 절대로 있어서는 안된다.
	
참고) 추상적인 함수
	=> abstract 속성이 부여되지 않아도 자동적으로 몸체가 존재하지 않는 추상함수
	
3. 인터페이스는 다른 클래스를 상속해 줄 수 있는데
이때 다중상속이 가능하다. 

4. 변수는 가질 수 있다.
이때 이 변수는 묵시적으로 
public static final 속성이 붙게된다.

5. 인터페이스 소속 함수는 묵시적으로 public abstract 함수가 된다.

----------------------------------------------------------
만드는 방법)
[접근지정자] interface 인터페이스이름 {
	변수; => 묵시적으로 public static final변수가 된다.
	함수(); => 묵시적으로 public abstract 함수가 된다. ( 추상함수)
}
----------------------------------------------------------
왜 인터페이스를 만들었나? 
=> 가끔은 JVM에 의해서 자동 호출되어야 하는 함수가 필요하다. 따라서 함수의 존재는
필요하다.

하지만 가끔은 이 함수가 해야할 일이 개발자의 몫인 경우가 존재한다.

따라서 기능은 개발자의 몫으로 남긴 것이다.

참고) 
 	자바에서 이벤트를 처리하는 순서
 		1. 사용자가 버튼을 클릭하면 이벤트가 발생한다.
 			이 이벤트는 운영체제가 인지하게 된다.
 		2. 운영체제는 자신이 인지한 이벤트가 발생한 프로그램을 구분해서
 		그 프로그램을 담당하는 플랫폼(JVM)에게 알려준다.
 		3.JVM은 통보받은 이벤트의 정보를 분석하여
 			그 정보에 합당한 함수를 호출하여 이벤트를 처리한다.
 			=> 그 정보에 합당한 함수를 호출한다는 것에 의미가 있다.
				결국 함수가 존재해야한다.
			=> 이벤트가 발생하면 무엇을 처리할 지는 JVM이 결정하는 것이 아니고
			개발자의 몫이 된다.
			
인터페이스 사용하기 
	1. 
		1) 인터페이스는 스스로 new 되지 못한다.
			(생성자함수를 호출하면서 인스턴스를 생성하지 못한다.)
			이유는 추상클래스와 마찬가지로 
			인터페이스 소속의 함수들은 모두 기능이 없는(몸체가 없는, 미완성인) 함수들로만
			구성되어있기 때문이다.
		
		따라서 추상클래스와 마찬가지로 일반 클래스에게 구현(상속)을 해준다.
		
		상속 방법)
			class 클래스이름 implements 인터페이스이름{
			}

		참고) 일반 클래스를 상속 받는 것을 "상속"이라고 표현하고 
		인터페이스를 상속받는 것은 "구현"이라고 한다.
		
		2) 상속받은 클래스에서는 인터페이스 안의 모든 함수를 100% 오버라이드 해야한다.
		그리고 필요한 기능은 개발자가 구현한다.
		=> 인터페이스 소속 함수는 자동적으로 public abstract 이다.
		
		3) 일반 클래스를 new 시켜서 사용한다.
			=> 이 방법은 인터페이스 사용의 90%를 차지한다.
			
	2. 약 10%정도는 
		반환값이 자기자신이면서 속성이 static 인 함수를 만들어서 사용할 수 있따.
		이때 추상 클래스와 차이점은 추상 클래스는 그 클래스 안에 그런 함수가 존재했지만
		인터페이스의 경우 다른 클래스에 이런 함수들이 존재하는 경우가 많다.
		
참고) 
	인터페이스는 다중 상속이 가능하다.
	
	형식 )
	
	class 클래스이름 implements 인터페이스1, 인터페이스2, ...{
		여기서는 상속받은 인터페이스의 모든 함수를 100%오버라이드 해야한다.
	}		

	참고) 만약 추상함수를 오버라이드 하지 않으면 추상클래스로 만들어야한다.
	
**
참고) 일반상속과 인터페이스 구현을 동시에 사용할 수 있따.

형식) 
	class 클래스이름 extends 상속해줄  클래스 이름 implements 인터페이스이름1, 인터페이스2 ,...
	{};
	
	주의사항) 이떄 반드시 extends가 먼저 와야한다.
			implements가 나중에 와야한다.
			
=====================================================
참고) 
	인터페이스도 다른 인터페이스를 상속받아서 만들 수 있다.
	형식) interface 인터페이스이름 extends  상속해줄 인터페이스이름{}
	
=====================================================

내부 클래스 
=> 클래스 안에 다시 클래스를 만들 때 
클래스 내부에 만들어지는 클래스를 내부클래스라 한다.

종류)
	1. Top Level Inner Class
	=> 비록 형식은 내부 클래스 이지만 
		독립적으로 활동하는 클래스를 얘기한다.
		
		형식)
		static class 클래스이름 {}
		
		정리하자면 내부클래스를 만들면서 static을 붙이면 Top Level 내부 클래스가 된다.
		
		참고)
			클래스이름 
			일반 클래스와 달리 내부 클래스의 이름은 "바깥 클래스이름.내부클래스 이름"의 형식을 취한다.
	***
	2. 전역 Inner Class
	=> 일반 클래스를 내부 클래스로 만든 것
	(이 클래스가 우리가 내부 클래스라고 부르는 것의 90%를 차지한다.)
	
	형식)
		class 클래스이름{}
	
	특징) 
		1. 바깥 클래스의 모든 멤버는 저절로 자기 것처럼 사용할 수 있다.
		2. 반드시 바깥 클래스가 new 된 이후에 안쪽 클래스를 생성할 수 있다.
		
	형식)
		바깥클래스주소.new 안쪽클래스이름();
		3. 바깥 클래스는 안쪽 클래스를 멤버를 사용할 수 없고
		사용하기 원하면 new시켜서 사용해야 한다.
		
		주로 바깥 클래스와 연관된 기능을 가진 클래스를 만들고 싶을 때 많이 사용하는 방법
		
	3. 지역 Inner Class
	=>내부 클래스를 만드는 위치가 바깥 클래스의 함수 안에서 만들 경우 이 클래스를 지역 내부
	클래스라고 한다.
	
	class Test{
		int a;=전역변수
		class C01{ => 전역 내부 클래스
		}
		void abc(){
		 int b;	=지역변수
		 	classC02{=지역내부클래스
		 	}
		}
	}
	
	특징)
		1. 전역 내부 클래스와 유사하게 바깥 클래스의 멤버를 모두 사용할 수 있따.
		2. 이 클래스는 다른 곳에서 new 시킬 수 없다.
			오직 해당함수 안에서만 new 시킬 수 있다.
			
	4. 무명 Inner Class
		=>말그대로 이름이 없는 내부 클래스를 이야기 한다.
		우리가 프로그램을 만들다 보면 클래스의 기능 수정을 위해서
		오버라이드를 해야하는 경우가 발생하는데 
		(어쩔 수 없이 반드시 오버라이드를 해야하는 경우(추상클래스, 인터페이스를 사용할 경우))
		
		이때는 원칙적인 규칙에 의해서 다른 클래스를 만들고 그 클래스에 필요한 클래스를
		상속을 한 후 오버라이드를 해야 하는 것이 원칙이다.
		
		그런데 이 때 간단한 오버라이드를 해야 하는 경우
		그 기능 하나때문에 클래스를 따로 제작해야하는 불편함이 있다.
		
		결론적으로 
		무명클래스란?
		이런 경우를 위해서 만들어진 클래스로 클래스를 new 시키는 순간 필요한 기능을 
		오버라이드해서 사용하는 방법이다.
		즉, 사용자가 클래스 이름을 만들지 않아도 된다.라는 의미에서 무명이라고 부른다.
		형식)
		new 상속해줄 클래스이름 (또는 구현할 인터페이스이름)( ){
			오버라이드 작업을 해준다.
		}
		
	--------------------------------------------------------------
	
	예외처리
	=> 프로그램적으로는 문제가 없으나(문법상 전혀 에러가 나지 발생하지 않으나)
	데이터의 문제나 장비의 문제 등에 의해서
	프로그램을 실행하는 도중 발생하는 에러를 "실행에러(Run Time Error)"라고 표현하고
	이것을 자바 에서 부르는 용어가 "예외(Exception)"이라고 부른다.
		
	문제는
	이런 예외는 개발자가 예측해서 이런 문제가 발생했을 경우
	대처하는 방식으로 프로그램을 만들어야하고 
	이처럼 예외가 발생했을 경우 대처하는 방식의 프로그램을 
	"예외처리"라고 부른다.
	
	자바에서는 이런문제점(예외발생원인을 개발자가 알고 잇어야 한다.)을  해결하기 위해서
	예외처리 문법이 존재한다.
	
	형식)
	
	1) 
	try{ 
		2)
		...예외가 발생할 요소가 존재하는 장소
		3)
	} catch(???){ 예외가 발생할 때 해결하는 부분
		4)
	} finally { 예외 발생 여부와 관계없이 마지막에 반드시 처리해줘야 할 부분, 필요하지 않으면 생략가능
		5)
	}	
	6)	
		
	실행순서 )
	
		1) --> 2) -->... 예외가 발생하지 않는 경우 	--> 3) --> 5)--> 6) 
						예외가 발생하는 경우   --> 4) --> 5) --> 6)
						
						
		참고) 
		문제는 3)이 문제인데 이 부분은 이전구문에서 예외가 발생하면 실행되지 않는다.
		따라서 try{}의 범위에 따라서 실행 할 수도 있고 실행되지 않을 수 도있다.
----------------------------------------------------------------		
	
	자바 예외처리 원리
		예외가 발생하면 JVM은 발생한 예외의 종류를 분석한 후
		예외에 대한 정보를 클래스로(객체)로 만들어서 
		catch 블럭에 그 클래스의 주소를 전달한다.
		
	catch의 의미
	=>예외가 발생하면 그 예외의 정보를 받아서 개발자가 그 정보를 이용해서 원하는 처리를 해줘야 한다.
	
	다중 catch
	=> try{}안에 예외 발생 요소가 여러가지 복합적인 예외 발생요소를 가질 수 있따.
	이때 반드시 어떤 에러 때문인지 구분해서 처리해야 한다면 
	이런 경우를 대비해서 만들어 놓은 방법이 다중 catch 이다.
	
	형식)
		try{
		}catch(???){
		}catch(???){
		}catch(???){
		}.....
		(finally{
		 생략가능
		})	
		
		***
		주의사항
			다중 catch를 사용하는 경우
			반드시 실행될 수 있는 상태로 만들어야 한다.
			
		예) String str = "";
			if(age<10){
				str ="유년기";
				}else if(age>=10){
				str = "10대";
				}else if(age>=20){
				str ="20대";
				}...
				
				*****
				이 경우처럼 예외처리도 catch블럭에 예외가 기술될 때 좁은 범위의 예외부터 기술하는 것이
				원칙이다.
		
		finally 블럭
		=>예외발생 여부와 관계없이 반드시 실행되어야할 문장이
		 존재할 경우이런 문장을 입력하는 블럭을 말한다.
=========================================================
	예외 정보 출력하기
	=> 다음 이유에 의해서 예외 정보를 얻을 수 있다.
	
	1. 예외 정보클래스 변수를 출력하면 된다.
		예)	
			System.out.println(예외정보클래스변수);
			=> 이렇게 처리하는 예외의 원인을 파악할 수 있게 된다.
			
	2. 예외변수.printStackTrace() 를 이용하는 방법
	=> 예외의 정보 + 예외가 발생하게 된 위치와 경로를 추적해서 출력한다.
	
	3. 예외처리는 예외가 발생하면 개발자가 그것을 수정해서 정상적으로 동작하도록 만드는
		행위라고 정의했다.
		(프로그램의 정상적인 종료)
		하지만 정상적으로 동작하도록 만드는 행위를 한다는 것은 
		매우 어려운 일이고 그 경우가 많지 않다. 
		
		다만 예외를 처리하는 실제 이유는 예외의 정보를 알아서 사용자에게 왜 프로그램에 문제가 발생했는지를
		알려주고 그 프로그램을 정상적으로 종료하도록 하는것에 목적이 있는 경우가 많다.
		
	=======================================================
예외  전이하기	
=> 함수는 프로그램의 가장 작은 단위로 
	한가지 작업을 하기 위해서 만든 것이다.
	따라서 함수 안에서 작업을 하다가 예외가 발생하면 
	그 함수는 더이상 실행할 필요가 없는 경우가 많다.
	그래서 함수는 예외를 전이하도록 해놓은 경우가 많이 있다.
	
	형식 ) 
		[접근지정자] [속성] 반환값타입 함수이름(매개변수리스트) 
		throws 예외클래스1. 예외클래스2, ...{
		
		} 	
		
	의미) 지정한 예외가 발생하면 이 함수는 더이상 실행해도 의미가 없으므로 실행을 중지시킨다.
	
	*****
	예외가 전이된 함수는 
	그 함수를 사용하는 곳에서 반드시 예외처리를 해줘야 한다.(==> try{}블럭안에 넣어서 처리하세요)
	
	참고) 
		try{}
		catch{}	
		등 {}블럭 기호 안에서 변수를 만들게 되면 이 변수는 해당 블럭 안에서만 사용하는 변수가 된다.
		따라서 예외처리 블럭 밖에서도 변수를 사용해야 한다면 반드시 예외처리가 시작하기 전에
		변수를 만들어서 사용해야 한다.
		
	참고) 
		어떤 함수가 예외를 전이하는 함수라도 예외처리를 하지 않아도 되는 경우가 있다.
		
		발생하는 예외가 RuntimeException 하위의 예외인 경우에는 
		예외처리를 해도 그만 안해도 그만이다.
		(java.lang 소속 클래스에 있는 함수들이 이런 함수들이 많이 존재한다.)
		
		하지만 될 수 있으면 하는 것이 좋다.
=======================================================
예외 강제 발생하기

형식 )
 	throw new 예외클래스이름();
		
		
		
		
		
		
		
		
		
		
		
















