#14

멤버변수의 초기화
=> 멤버변수는(Field)는 Heap 영역에 생기므로 자동 초기화 된다.
하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.

 1. 명시적 초기화 
  = 변수를 선언하면서 값을 입력하는 방법
     가장먼저 실행되는 방법
     
     예) 
     class Test{
     	int num =100;
     	}//명시적 초기화
 2. 초기화 블럭을 이용한 초기화
 =이것은 인스턴스 변수에 대해서만 가능한 것으로 
 두번째로 실행되는 방법

형식 )
		{
		 	이 안에 데이터를 변수에 입력
		}
		예)
		class Test{
			int num;
			...
			{ ==> 초기화 블럭 class 블럭 아래에 있음
				num=10; //초기화 블럭을 이용한 초기화
			}	
		}

 3. static 블럭을 이용한 초기화
 = 2번과 반대로 static 변수에 한해서만 가능한 방법
 두번째로 실행되는 방법
 
 형식 )
  static{
  	==>static블럭
	데이터 입력..
  }
 예) class Test{
 	static int num;
 	...
 	static {
 		num=50;
 	}
 }
 4. 생성자 함수를 이용한 초기화
 => 가장 마지막에 실행되는 방법
 
 생성자 함수의 역할 : 초기화
 
 예) class Test {
 int num;
 	public Test(){
 	 num=200;
 	}
 }
 
 ===========================================
 객체지향언어의 특징
 1. 상속 		: 
 2. 다형성
 3. 은닉화/캡슐화 :변수는 다른 클래스에서 접근하지 못하도록 한다.
 				데이터를 꺼내거나 입력하는 작업은 함수를 만들어서 처리하도록 하는 방법
 ========================================
 상속
 =>이미 만들어진 클래스의 기능을 그대로 부여받아서(변수와 함수의 기능을 그대로 복사받아서)
 새로운 클래스를 만드는 방법
 
 이 개념이 나타난 이유는 
 소프트웨어의 개발속도를 빠르게 하기 위한 한가지 방법이다.
 
 즉, 상속은 객체지향에서 매우 중요한 역할을 하는 것으로..
 
 객체 지향언어는 부품 단위(클래스)로 프로그램을 만든 후 그 부품을 조립해서 원하는 결과를
 얻어내는 것이다.
 
 어디서 부품(클래스)을 구했는데
 그 기능이 사용자 마음에 꼭 맞지 않을 수 있다.
 그러면 처음부터 다시 만들어야 하는가?란 문제를 해결하기 위해 만든 방법 = 상속

상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서 일단 그 기능을 모두 복사한 후
1. 없는 기능은 덧붙이고
2. 있는 기는중에 바꿀내용만 바꾸자
라는 것이 상속
=============================================
***외우기
상속의 형식 )
	[접근지정자] [속성] class 클래스이름  extends 상속해줄 클래스이름 {
		이 안에는 우리 눈에 안보이더라도 상속 해줄 클래스의 멤버들이 모두 포함되어있다.
	} 
 
 =>따라서 상속을 받아서 만드는 클래스는 상속해주는 클래스보다 멤버(변수,함수)가 늘어난다.
 
 ***
 참고) 자바는 오직 단일 상속만 가능하다.
 => 상속해주는 클래스는 한개여야만한다.
 
 예) class NewClass extends Old01,Old02 {//한개만 와야됨
 
 }===안됨
 
 class NewClass extends Old01{
 }==가능
 
 용어정리 )
 상속을 해준 클래스 - super Class (상위클래스,부모클래스)
 상속을 받은 클래스 -	sub Class (하위 클래스,자식클래스)

is a  => 상속관계에 있는 클래스를 부르는 용어
			class Father{}
			class Son extends Father{}
			
			이 경우 Son is a Father 가 성립된다.
			상위클래스의 멤버가 하위클래스보다 적다.
			
has a => 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
			class Father {}
			class Son{
			 Father f = new Father(); //멤버로 가지고 잇는 상태
			}
			
			참조형 변수 heap 영역, 공간이 필요하면 알아서 늘림
			기본데이터 타입은 리터럴 풀
			이 경우  Son has a Father 가 성립된다. 
=================================================
상속 관계에 있는 경우 생성자의 역할

결론 : 하위 클래스가 생성되는 순간
상위 클래스가 자동 생성된다.
=> 생성되는 순간 생성자 함수가 호출되므로 결국 하위클래스를 생성하면 상위 클래스의 생성자
함수도 실행된다.

결론적으로 상위 클래스의 생성자함수는 자동으로 호출되는 개념이다.
자동 호출되는 경우는 무조건 기본 생성자만 이용하게 된다.
참고) 기본생성자 : 매개변수가 없는 생성자.

**
참고 ) super()
상위 클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 명령

특징) 1.반드시 생성자 함수 안에서만 사용해야 한다.
	2. 반드시 첫줄 첫문장으로 사용해야 한다.
	
====================================================

***
함수의 오버라이딩 (Overriding : 함수의 재정의)
=> 상속 관계에 있는 하위 클래스에서 상위클래스가 가진 함수의 기능을 수정하는 행위

방법)
	0. 상속을 받아야 한다.
	1. 상위 클래스가 가진 함수의 원형과 동일한 원형으로 만들어야한다.
		 참고)함수의 원형(Prototype)
		 	반환값타입 + 함수이름 + 매개변수리스트 
	2. 접근지정자는 같거나 넓은 방향으로 한다.
	3. 예외처리는 같거나 좁은 방향으로 한다.
	
	이렇게 오버라이딩을 하면 내부적으로 super의 상위클래스에 함수가 숨겨지고 재정의한
	함수가 사용된다.
	
	예) class Father {
			void abc(int a){
			}
		}
		
		class Son extends Father{
			void abc(int a){
				함수 내용 수정.=> 기능을 변경
	
	
			};
		}	
	*******
	참고) super 
		=>this가 실행중인 객체 자기자신을 기억하는 예약된 변수이듯이 super역시
		예약된 변수 중 하나이다.
		자신의 상위 클래스 주소가 기억된 변수이다.
		
		사용목적)
		반드시 상위 클래스 멤버임을 밝혀야하는 경우가 생길 때 사용한다.
		
========================================================
******참고
상속관계에 있는 클래스에서 함수는 인스턴스쪽을 따르고 변수는 레퍼런스쪽을 따른다. 
=> 가보는 건드리면 안됩니다.

========================================================
접근지정자
=> 그 내용을 어디까지 사용할 수 있게 할 것인지를 지정하는 예약된 용어
즉, 우리가 클래스를 만들면 그 클래스를 모든 사람들에게 사용할 수 있게 공개해야 되는 것은 아니다.
클래스를 제작하는 사람이 제작하는 클래스의 사용 범위를 지정할 수 있다.

예) class는 누구까지 이 클래스를 사용하게 하도록 할까?
	new를 시킬 수 있도록 할 것인가??
	
	함수는 어디까지 이 함수를 호출할 수 있도록 할 것인가?
	
	
	종류)
	1. private
		= 절대로 다른 클래스에서는 사용할 수 없고 
	  오직 자기 자신 클래스 내에서만 사용할 수 있다.
	2. 생략
		= 같은 패키지 소속의 클래스에서는 사용할 수 있따.
	3. protected
		=같은 패키지 소속의 클래스에서 그리고 상속받은 하위 클래스에서만 사용가능하다.
	4. public
		= 모든 곳에서 사용가능하다.
		
	참고)
		클래스에서는 public 과 생략만 사용할 수 있다.
		
	참고)
		클래스의 접근지정의 의미는 클래스 자체를 사용할 지 여부를 지정하는 것이고
		생성자함수의 접근지정의 의미는 new 시킬 수 있는지 여부를 지정하는 것이다.
		
***		
은닉화
== 프로그램에 있어서 가장 중요한 요소는 데이터이다.
즉, 변수가 프로그램에서의 핵심적인 요소가 된다.
무결성 데이터를 유지할 수 있는것이 가장 중요한 개념이다.

은닉화란?
이처럼 중요한 요소인 변수를 사용자가 함부로 변경하지 못하도록
(결점이 있는 데이터가 오지 못하도록 하는 것) 방지하는 기법을 은닉화라고 한다.

방법) 1. 변수의 접근지정자는 private로 처리한다.
		=다른 클래스에서 해당 클래스의 변수에 직접 접근할 수 없게된다.
	 2. 변수의 값을 변경하거나 값을 꺼내오는 작업은 함수를 통해 처리한다.
	 	=getxxx(),setxxx() 함수를 만들어서 처리한다. 	

===========================================================
package와 import
 package = 자바 프로그램 소스코드가 들어있는 폴더를 
 			자바에서 부르는 용어		
		
		자바는 오픈 소스이다.
		모든 사람이 자신이 만든 프로그램을 제공할 수 있고
		그것을 모든 사람이 이용할  수 있는 프로그램이다.
		그러다보니 발생한 문제
			클래스 이름이 출동이 날 수 있겠다.
		이런 문제를 해결하기 위해서 만들어 놓은 한가지 방법이 패키지이다.
		
		즉, 소스코드를 만드는 사람이 그 프로그램이 포함되는 폴더 이름까지 
		정해서 프로그램을 만들도록 하는 것..
		
		결론적으로 자바로 프로그램을 만들 떄는 반드시 해당 프로그램이 어떤
		폴더에 저장되는지를 알려주도록 해 놓았다.
		
		명령}
		package 폴더이름;
		
		참고)
		패키지 이름을 만드는 권장사항
		
		자신이 사용하는 도메인을 거꾸로 쓴 후 그 다음에 다시 폴더이름을 붙여서 사용하세요
		
		예) increpas.com
		==>com.increpas.day14;
		
	-------------------------------------------------------
	import
	=> 자신이 사용할 클래스가 어떤 폴더(패키지) 소속의 클래스 인지를 밝혀주기 위한 명령
	
	예) 
		내가 
			sample
				|---Test.class
			test
				|---Test.class
				
		형식 1 )
		import  패키지경로.클래스 이름;
		=>지정한 폴더에 있는 클래스를 사용할 예정임을 밝히는 것.
		
		형식 2)
		import 패키지경로.*; 
		=> 지정한 폴더에 있는 모든 클래스를 사용할 준비를 해주는것.
		import 했다고 new 시켜주진 않는다.
		
		
		참고) 형식2번보다 형식1번을 우선시 한다.
		
참고) import 하지 않아도 명시적으로 클래스 이름앞에 패키지 이름을 붙여서
사용할 수 도있다.

=====================================================
참고)
	유일하게 java.lang 패키지는 import 시키지 않아도 사용할 수 있따.
	이유: JVM이 기본적으로 찾아보는 패키지이기 때문이다.
	
	주의)
	import를 하게 되면 해당 패키지만 선언하게 되는 것이다.
	그 상위나 하위는 포함되지 않는다.
	
	p1-------T1
		 |---T2
		 |---T3
		 |-p2-----Q1
		       |--Q2
			   |--Q3
			   
import p1.*;
=이경우 p1 폴더 바로 하위의 클래스들만 사용할 준비를 하는것이다.
p2패키지 소속의 클래스들은 사용할 준비를 하는것이 아니다.

static import
=> static 멤버는 원칙적으로 클래스이름.멤버의 형식으로 사용해야 한다.

예) Math.random();
	Math.PI;
	이 때 static 멤버앞에 사용하는 클래스 이름 조차도 생략할 수 있따.
	=> 이처럼 static 멤버를 사용할 때 
		클래스 이름을 생략하도록 하는 방법이 static import이다
		
형식) 
	import static 패키지이름.클래스이름.*;



















		
			