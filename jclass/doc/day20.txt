#day 20 

Map
=> 하나의 데이터를 그 데이터를 구분할 수 있는 키값과 한 쌍으로 만들어서
데이터를 기억하는 컬렉션의 일종 그리고 사용할 경우에는 키값을 이용해서 
데이터를 꺼낼 수 있도록 한 것이 된다.

Map계열은 많은 양의 데이터를 보관하는 용도보다는 데이터를 손쉽게
구분하여 사용할 목적으로 사용된다.

Hashtable /HashMap

	Hashtable이 구버전이고 HashMap이 나중에 나온 클래스이다.
	
	내부적으로 키값을 해쉬 테이블을 이용해서 정렬해서 보관한다.
	
	주요함수 
		put(Object key, Object value)
		=> 데이터를 입력하는 함수
		get(Object key)
		=>필요한 데이터를 꺼내는 함수
		
		참고 함수
		
			values()
			-키값은 놓아두고 데이터만 꺼내서 반환해주는 함수
			
			keys()
			- 키값만 꺼내서 반환해주는 함수(Hashtable 에만 존재하는 함수)
			
			keySet()
			- 키값만 꺼내서 반환해주는함수(해쉬테이블, 해쉬맵둘다 사용할 수 있다.
					Map계열에서는 모두 사용가능)
			
			-원래는 keys였는데 keySet()으로 버전업했다.
			
			entrySet()
			-Map은 반드시 키값을 알아야 데이터를 꺼낼 수 있다.
			-키값과 데이터를 Set으로 묶어주는 함수
			
			-주의) Map은 항상 키와 밸류 두개가 있어야 저장된다.
			Set은 데이터 한개만 있으면 저장이 된다.
			따라서 키값과 데이터를 하나로 묶어야 한다.
			Set에 저장이 된다.
			
			이때 이문제를 해결하기 위한 클래스(VO 클래스)가 존재한다.
			그 클래스가 바로 Map.Entry
			=>이 클래스 안에는 key와 value변수를 은닉화 시켜놓고 
				이 변수를 사용할 수 있는 함수를 제공함으로써 두개의
				변수를 하나로 묶어놓은클래스이다.
				
				
TreeMap 
=> TreeSet과 마찬가지로 내부에서 정렬하면서 데이터를 기억하는 Map이다.
이때 정렬기준은 키값을 이용해서 정렬하게 된다.
따라서 키값이 정렬이 되지 않는 클래스는 사용할 수 없고
필요하다면 정렬방식을 정해서 사용해야 한다.

Tmp abc(){
	int a = 10;
	String b= "홍길동";
	Tmp t = new Tmp();
	t.a= a;
	t.b= b;
	
	return t;
	}
	
	=이 처럼 클래스를 보면 가끔은 무슨 기능을 필요로 해서 만들어지는 것이 아니고
	여러개의 데이터를 하나로 묶기 위한 목적으로 만들어 놓은 클래스가 있다.
	
	class Tmp{
	
		int a;
		String b;
		
		}
		// 이런 클래스를 우리는 데이터 빈 클래스라고도 하고
		또는 Value Object(VO)라고도 한다.
		DTO(Data Transfer Object)라고도 부른다.
		
----------------------------------------------------------
참고)
	컬렉션 안에는 다시 컬렉션을 입력할 수 있다.
	왜? - 컬렉션 안에는 모든 클래스를 입력할 수 있으므로 
			컬렉션도 클래스이므로 저장이 가능하다.
==========================================================

Properties
=> Map의 역할을 하는 클래스

	일반 Map과의 차이점은 파일(외부장치)를 이용해서 직접 데이터를 읽어서
	Map처럼 저장할 수 있고 Map에 저장된 데이터를 직접 파일(외부장치)로 출력해서 저장할 수 있다.
	
	주의사항)
	***
	파일의 내용을 읽을 때 엔코딩이 되지 않는다.
	=> 한글 파일의 경우 파일 자체에서 엔코딩을 하지 않으면 내용이 한글인 경우
	한글이 깨져서 들어온다.
	
	=> 해결방법)
		한글이 포함된 파일을 Properties에서 사용하기 위해서 엔코딩 시키는 방법
		
		1. cmd창을 연다
		2. path를 wkqk home 으로 잡아준다.
		3. native2ascii 기능을 이용해서 엔코딩 해준다.
		
		형식) 
		native2ascii 인코딩할파일 저장될파일
		
	참고) 
		Properties는 클래스는 오직 문자열만 String으로만 키값과 데이터를 처리해야 한다.
		
	참고)
		Properties는 이 외에도 하나의 특징을 가지고 있는데 
		현재 프로그램의 정보를 Map으로 자동처리하는 기능을 가지고 있다.
		
=========================================================================
제너릭스
=> 컬렉션은 모든 형태의 데이터를 다 입력받을 수 이따.
하지만 실무에서는 한가지 형태로 입력 받는 것을 원칙으로 한다.
이 때 꺼낼 때는 항상 형변환을 해서 꺼내야 한다.
즉, 한가지 형태로 데이터를 입력해 놓았는데 
꺼낼 때는 자동 형변환이 일어나지 않기 때문에 항상 강제형변환을 해줘야한다.

제너릭스란?
=> 컬렉션에 입력하는 데이터를 미리 알려줌으로써
나중에 꺼내서 쓸때 좀더 편하게 (강제형변환없이) 꺼낼 수 있도록 해주는 것.

형식)
ArrayList<String> list = new ArrayList<String>();
=> 이때 list 에는 문자열 데이터만 입력할 수 있게된다.
꺼낼 때는 자동으로 문자열 타입으로 꺼내게 된다.

참고) 
반드시 컬렉션마다 모두 제너릭스 선언을 해줘야 한다.

참고)
제너릭스는 전파되지 않는다.
하나의 컬렉션이 제너릭스 선언이 되었더라도 그 컬렉션을 이용하는 다른 
컬렉션은 제너릭스를  잊어버리게 된다.			
따라서 새로운 컬렉션도 다시 제너릭스 선언을 해줘야한다.

참고) 
특수한 제너릭스 
원래 제너릭스는 특정클래스만 입력 받을 목적으로 사용이 된다.

형식)
<? super클래스이름>
=> 지정한 클래스포함 상위 클래스까지 허락

<? extends 클래스이름>
=지정한 클래스 포함 하위 클래스 까지 허락한다는 의미

이 방법은 제너릭스를 선언하지 않은것과 동일한 효과이다.

===============================================================
어노테이션
=> 내부적으로 약속된 실행을 자동으로 처리하도록 하는 명령의 일종이다.
주로 화면에 실제보이는 실행이 아니고 점검을 한다든지.
선언적인 실행(이 클래스는 어떻게 동작하세요..)의 의미를가진 명령

형식)
@명령			
			
			
			
			
			
			
			
			